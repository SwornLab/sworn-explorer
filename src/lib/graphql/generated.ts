import client from "../apollo.ts";
import type {
        ApolloQueryResult, ObservableQuery, WatchQueryOptions, QueryOptions
      } from "@apollo/client";
import { readable } from "svelte/store";
import type { Readable } from "svelte/store";
import gql from "graphql-tag"
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  BigInt: { input: any; output: any; }
  Bytes: { input: any; output: any; }
  Cursor: { input: any; output: any; }
  Uint: { input: any; output: any; }
};

export type AssetPrice = Node & {
  __typename?: 'AssetPrice';
  asset?: Maybe<Scalars['String']['output']>;
  block: Scalars['Uint']['output'];
  chain?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  pair?: Maybe<Scalars['String']['output']>;
  price: Scalars['Uint']['output'];
  signature: Scalars['Bytes']['output'];
  signers: Array<Signer>;
  signerscount?: Maybe<Scalars['Uint']['output']>;
};

/** A connection to a list of items. */
export type AssetPriceConnection = {
  __typename?: 'AssetPriceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AssetPriceEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type AssetPriceEdge = {
  __typename?: 'AssetPriceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AssetPrice>;
};

/** Ordering options for AssetPrice connections */
export type AssetPriceOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order AssetPrices. */
  field: AssetPriceOrderField;
};

/** Properties by which AssetPrice connections can be ordered. */
export enum AssetPriceOrderField {
  Block = 'BLOCK'
}

/**
 * AssetPriceWhereInput is used for filtering AssetPrice objects.
 * Input was generated by ent.
 */
export type AssetPriceWhereInput = {
  and?: InputMaybe<Array<AssetPriceWhereInput>>;
  /** asset field predicates */
  asset?: InputMaybe<Scalars['String']['input']>;
  assetContains?: InputMaybe<Scalars['String']['input']>;
  assetContainsFold?: InputMaybe<Scalars['String']['input']>;
  assetEqualFold?: InputMaybe<Scalars['String']['input']>;
  assetGT?: InputMaybe<Scalars['String']['input']>;
  assetGTE?: InputMaybe<Scalars['String']['input']>;
  assetHasPrefix?: InputMaybe<Scalars['String']['input']>;
  assetHasSuffix?: InputMaybe<Scalars['String']['input']>;
  assetIn?: InputMaybe<Array<Scalars['String']['input']>>;
  assetIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  assetLT?: InputMaybe<Scalars['String']['input']>;
  assetLTE?: InputMaybe<Scalars['String']['input']>;
  assetNEQ?: InputMaybe<Scalars['String']['input']>;
  assetNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  assetNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** block field predicates */
  block?: InputMaybe<Scalars['Uint']['input']>;
  blockGT?: InputMaybe<Scalars['Uint']['input']>;
  blockGTE?: InputMaybe<Scalars['Uint']['input']>;
  blockIn?: InputMaybe<Array<Scalars['Uint']['input']>>;
  blockLT?: InputMaybe<Scalars['Uint']['input']>;
  blockLTE?: InputMaybe<Scalars['Uint']['input']>;
  blockNEQ?: InputMaybe<Scalars['Uint']['input']>;
  blockNotIn?: InputMaybe<Array<Scalars['Uint']['input']>>;
  /** chain field predicates */
  chain?: InputMaybe<Scalars['String']['input']>;
  chainContains?: InputMaybe<Scalars['String']['input']>;
  chainContainsFold?: InputMaybe<Scalars['String']['input']>;
  chainEqualFold?: InputMaybe<Scalars['String']['input']>;
  chainGT?: InputMaybe<Scalars['String']['input']>;
  chainGTE?: InputMaybe<Scalars['String']['input']>;
  chainHasPrefix?: InputMaybe<Scalars['String']['input']>;
  chainHasSuffix?: InputMaybe<Scalars['String']['input']>;
  chainIn?: InputMaybe<Array<Scalars['String']['input']>>;
  chainIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  chainLT?: InputMaybe<Scalars['String']['input']>;
  chainLTE?: InputMaybe<Scalars['String']['input']>;
  chainNEQ?: InputMaybe<Scalars['String']['input']>;
  chainNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  chainNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** signers edge predicates */
  hasSigners?: InputMaybe<Scalars['Boolean']['input']>;
  hasSignersWith?: InputMaybe<Array<SignerWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<AssetPriceWhereInput>;
  or?: InputMaybe<Array<AssetPriceWhereInput>>;
  /** pair field predicates */
  pair?: InputMaybe<Scalars['String']['input']>;
  pairContains?: InputMaybe<Scalars['String']['input']>;
  pairContainsFold?: InputMaybe<Scalars['String']['input']>;
  pairEqualFold?: InputMaybe<Scalars['String']['input']>;
  pairGT?: InputMaybe<Scalars['String']['input']>;
  pairGTE?: InputMaybe<Scalars['String']['input']>;
  pairHasPrefix?: InputMaybe<Scalars['String']['input']>;
  pairHasSuffix?: InputMaybe<Scalars['String']['input']>;
  pairIn?: InputMaybe<Array<Scalars['String']['input']>>;
  pairIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  pairLT?: InputMaybe<Scalars['String']['input']>;
  pairLTE?: InputMaybe<Scalars['String']['input']>;
  pairNEQ?: InputMaybe<Scalars['String']['input']>;
  pairNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  pairNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** price field predicates */
  price?: InputMaybe<Scalars['Uint']['input']>;
  priceGT?: InputMaybe<Scalars['Uint']['input']>;
  priceGTE?: InputMaybe<Scalars['Uint']['input']>;
  priceIn?: InputMaybe<Array<Scalars['Uint']['input']>>;
  priceLT?: InputMaybe<Scalars['Uint']['input']>;
  priceLTE?: InputMaybe<Scalars['Uint']['input']>;
  priceNEQ?: InputMaybe<Scalars['Uint']['input']>;
  priceNotIn?: InputMaybe<Array<Scalars['Uint']['input']>>;
  /** signersCount field predicates */
  signerscount?: InputMaybe<Scalars['Uint']['input']>;
  signerscountGT?: InputMaybe<Scalars['Uint']['input']>;
  signerscountGTE?: InputMaybe<Scalars['Uint']['input']>;
  signerscountIn?: InputMaybe<Array<Scalars['Uint']['input']>>;
  signerscountIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  signerscountLT?: InputMaybe<Scalars['Uint']['input']>;
  signerscountLTE?: InputMaybe<Scalars['Uint']['input']>;
  signerscountNEQ?: InputMaybe<Scalars['Uint']['input']>;
  signerscountNotIn?: InputMaybe<Array<Scalars['Uint']['input']>>;
  signerscountNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CorrectnessReport = Node & {
  __typename?: 'CorrectnessReport';
  correct: Scalars['Boolean']['output'];
  hash: Scalars['Bytes']['output'];
  id: Scalars['ID']['output'];
  signature: Scalars['Bytes']['output'];
  signers: Array<Signer>;
  signerscount: Scalars['Uint']['output'];
  timestamp: Scalars['Uint']['output'];
  topic: Scalars['Bytes']['output'];
};

/** A connection to a list of items. */
export type CorrectnessReportConnection = {
  __typename?: 'CorrectnessReportConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CorrectnessReportEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CorrectnessReportEdge = {
  __typename?: 'CorrectnessReportEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CorrectnessReport>;
};

/** Ordering options for CorrectnessReport connections */
export type CorrectnessReportOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order CorrectnessReports. */
  field: CorrectnessReportOrderField;
};

/** Properties by which CorrectnessReport connections can be ordered. */
export enum CorrectnessReportOrderField {
  Timestamp = 'TIMESTAMP'
}

/**
 * CorrectnessReportWhereInput is used for filtering CorrectnessReport objects.
 * Input was generated by ent.
 */
export type CorrectnessReportWhereInput = {
  and?: InputMaybe<Array<CorrectnessReportWhereInput>>;
  /** correct field predicates */
  correct?: InputMaybe<Scalars['Boolean']['input']>;
  correctNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** signers edge predicates */
  hasSigners?: InputMaybe<Scalars['Boolean']['input']>;
  hasSignersWith?: InputMaybe<Array<SignerWhereInput>>;
  hash?: InputMaybe<Scalars['String']['input']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<CorrectnessReportWhereInput>;
  or?: InputMaybe<Array<CorrectnessReportWhereInput>>;
  /** signersCount field predicates */
  signerscount?: InputMaybe<Scalars['Uint']['input']>;
  signerscountGT?: InputMaybe<Scalars['Uint']['input']>;
  signerscountGTE?: InputMaybe<Scalars['Uint']['input']>;
  signerscountIn?: InputMaybe<Array<Scalars['Uint']['input']>>;
  signerscountLT?: InputMaybe<Scalars['Uint']['input']>;
  signerscountLTE?: InputMaybe<Scalars['Uint']['input']>;
  signerscountNEQ?: InputMaybe<Scalars['Uint']['input']>;
  signerscountNotIn?: InputMaybe<Array<Scalars['Uint']['input']>>;
  /** timestamp field predicates */
  timestamp?: InputMaybe<Scalars['Uint']['input']>;
  timestampGT?: InputMaybe<Scalars['Uint']['input']>;
  timestampGTE?: InputMaybe<Scalars['Uint']['input']>;
  timestampIn?: InputMaybe<Array<Scalars['Uint']['input']>>;
  timestampLT?: InputMaybe<Scalars['Uint']['input']>;
  timestampLTE?: InputMaybe<Scalars['Uint']['input']>;
  timestampNEQ?: InputMaybe<Scalars['Uint']['input']>;
  timestampNotIn?: InputMaybe<Array<Scalars['Uint']['input']>>;
  topic?: InputMaybe<Scalars['String']['input']>;
};

export type EventLog = Node & {
  __typename?: 'EventLog';
  address: Scalars['String']['output'];
  args: Array<EventLogArg>;
  block: Scalars['Uint']['output'];
  chain: Scalars['String']['output'];
  event: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  index: Scalars['Uint']['output'];
  signature: Scalars['Bytes']['output'];
  signers: Array<Signer>;
  signerscount: Scalars['Uint']['output'];
  transaction: Scalars['Bytes']['output'];
};

export type EventLogArg = {
  __typename?: 'EventLogArg';
  name: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

/** A connection to a list of items. */
export type EventLogConnection = {
  __typename?: 'EventLogConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EventLogEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type EventLogEdge = {
  __typename?: 'EventLogEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<EventLog>;
};

/** Ordering options for EventLog connections */
export type EventLogOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order EventLogs. */
  field: EventLogOrderField;
};

/** Properties by which EventLog connections can be ordered. */
export enum EventLogOrderField {
  Block = 'BLOCK'
}

/**
 * EventLogWhereInput is used for filtering EventLog objects.
 * Input was generated by ent.
 */
export type EventLogWhereInput = {
  /** address field predicates */
  address?: InputMaybe<Scalars['String']['input']>;
  addressContains?: InputMaybe<Scalars['String']['input']>;
  addressContainsFold?: InputMaybe<Scalars['String']['input']>;
  addressEqualFold?: InputMaybe<Scalars['String']['input']>;
  addressGT?: InputMaybe<Scalars['String']['input']>;
  addressGTE?: InputMaybe<Scalars['String']['input']>;
  addressHasPrefix?: InputMaybe<Scalars['String']['input']>;
  addressHasSuffix?: InputMaybe<Scalars['String']['input']>;
  addressIn?: InputMaybe<Array<Scalars['String']['input']>>;
  addressLT?: InputMaybe<Scalars['String']['input']>;
  addressLTE?: InputMaybe<Scalars['String']['input']>;
  addressNEQ?: InputMaybe<Scalars['String']['input']>;
  addressNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  and?: InputMaybe<Array<EventLogWhereInput>>;
  /** block field predicates */
  block?: InputMaybe<Scalars['Uint']['input']>;
  blockGT?: InputMaybe<Scalars['Uint']['input']>;
  blockGTE?: InputMaybe<Scalars['Uint']['input']>;
  blockIn?: InputMaybe<Array<Scalars['Uint']['input']>>;
  blockLT?: InputMaybe<Scalars['Uint']['input']>;
  blockLTE?: InputMaybe<Scalars['Uint']['input']>;
  blockNEQ?: InputMaybe<Scalars['Uint']['input']>;
  blockNotIn?: InputMaybe<Array<Scalars['Uint']['input']>>;
  /** chain field predicates */
  chain?: InputMaybe<Scalars['String']['input']>;
  chainContains?: InputMaybe<Scalars['String']['input']>;
  chainContainsFold?: InputMaybe<Scalars['String']['input']>;
  chainEqualFold?: InputMaybe<Scalars['String']['input']>;
  chainGT?: InputMaybe<Scalars['String']['input']>;
  chainGTE?: InputMaybe<Scalars['String']['input']>;
  chainHasPrefix?: InputMaybe<Scalars['String']['input']>;
  chainHasSuffix?: InputMaybe<Scalars['String']['input']>;
  chainIn?: InputMaybe<Array<Scalars['String']['input']>>;
  chainLT?: InputMaybe<Scalars['String']['input']>;
  chainLTE?: InputMaybe<Scalars['String']['input']>;
  chainNEQ?: InputMaybe<Scalars['String']['input']>;
  chainNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** event field predicates */
  event?: InputMaybe<Scalars['String']['input']>;
  eventContains?: InputMaybe<Scalars['String']['input']>;
  eventContainsFold?: InputMaybe<Scalars['String']['input']>;
  eventEqualFold?: InputMaybe<Scalars['String']['input']>;
  eventGT?: InputMaybe<Scalars['String']['input']>;
  eventGTE?: InputMaybe<Scalars['String']['input']>;
  eventHasPrefix?: InputMaybe<Scalars['String']['input']>;
  eventHasSuffix?: InputMaybe<Scalars['String']['input']>;
  eventIn?: InputMaybe<Array<Scalars['String']['input']>>;
  eventLT?: InputMaybe<Scalars['String']['input']>;
  eventLTE?: InputMaybe<Scalars['String']['input']>;
  eventNEQ?: InputMaybe<Scalars['String']['input']>;
  eventNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** signers edge predicates */
  hasSigners?: InputMaybe<Scalars['Boolean']['input']>;
  hasSignersWith?: InputMaybe<Array<SignerWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** index field predicates */
  index?: InputMaybe<Scalars['Uint']['input']>;
  indexGT?: InputMaybe<Scalars['Uint']['input']>;
  indexGTE?: InputMaybe<Scalars['Uint']['input']>;
  indexIn?: InputMaybe<Array<Scalars['Uint']['input']>>;
  indexLT?: InputMaybe<Scalars['Uint']['input']>;
  indexLTE?: InputMaybe<Scalars['Uint']['input']>;
  indexNEQ?: InputMaybe<Scalars['Uint']['input']>;
  indexNotIn?: InputMaybe<Array<Scalars['Uint']['input']>>;
  not?: InputMaybe<EventLogWhereInput>;
  or?: InputMaybe<Array<EventLogWhereInput>>;
  /** signersCount field predicates */
  signerscount?: InputMaybe<Scalars['Uint']['input']>;
  signerscountGT?: InputMaybe<Scalars['Uint']['input']>;
  signerscountGTE?: InputMaybe<Scalars['Uint']['input']>;
  signerscountIn?: InputMaybe<Array<Scalars['Uint']['input']>>;
  signerscountLT?: InputMaybe<Scalars['Uint']['input']>;
  signerscountLTE?: InputMaybe<Scalars['Uint']['input']>;
  signerscountNEQ?: InputMaybe<Scalars['Uint']['input']>;
  signerscountNotIn?: InputMaybe<Array<Scalars['Uint']['input']>>;
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars['ID']['output'];
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']['output']>;
};

export type Query = {
  __typename?: 'Query';
  assetPrices: AssetPriceConnection;
  correctnessReports: CorrectnessReportConnection;
  eventLogs: EventLogConnection;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  signers: SignerConnection;
};


export type QueryAssetPricesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<AssetPriceOrder>;
  where?: InputMaybe<AssetPriceWhereInput>;
};


export type QueryCorrectnessReportsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<CorrectnessReportOrder>;
  where?: InputMaybe<CorrectnessReportWhereInput>;
};


export type QueryEventLogsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<EventLogOrder>;
  where?: InputMaybe<EventLogWhereInput>;
};


export type QueryNodeArgs = {
  id: Scalars['ID']['input'];
};


export type QueryNodesArgs = {
  ids: Array<Scalars['ID']['input']>;
};


export type QuerySignersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SignerOrder>;
  where?: InputMaybe<SignerWhereInput>;
};

export type Signer = Node & {
  __typename?: 'Signer';
  assetprice?: Maybe<Array<AssetPrice>>;
  correctnessreport?: Maybe<Array<CorrectnessReport>>;
  eventlogs?: Maybe<Array<EventLog>>;
  evm?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  key: Scalars['Bytes']['output'];
  name: Scalars['String']['output'];
  points: Scalars['Int']['output'];
  shortkey: Scalars['Bytes']['output'];
};

/** A connection to a list of items. */
export type SignerConnection = {
  __typename?: 'SignerConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SignerEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type SignerEdge = {
  __typename?: 'SignerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Signer>;
};

/** Ordering options for Signer connections */
export type SignerOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Signers. */
  field: SignerOrderField;
};

/** Properties by which Signer connections can be ordered. */
export enum SignerOrderField {
  Points = 'POINTS'
}

/**
 * SignerWhereInput is used for filtering Signer objects.
 * Input was generated by ent.
 */
export type SignerWhereInput = {
  and?: InputMaybe<Array<SignerWhereInput>>;
  /** evm field predicates */
  evm?: InputMaybe<Scalars['String']['input']>;
  evmContains?: InputMaybe<Scalars['String']['input']>;
  evmContainsFold?: InputMaybe<Scalars['String']['input']>;
  evmEqualFold?: InputMaybe<Scalars['String']['input']>;
  evmGT?: InputMaybe<Scalars['String']['input']>;
  evmGTE?: InputMaybe<Scalars['String']['input']>;
  evmHasPrefix?: InputMaybe<Scalars['String']['input']>;
  evmHasSuffix?: InputMaybe<Scalars['String']['input']>;
  evmIn?: InputMaybe<Array<Scalars['String']['input']>>;
  evmIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  evmLT?: InputMaybe<Scalars['String']['input']>;
  evmLTE?: InputMaybe<Scalars['String']['input']>;
  evmNEQ?: InputMaybe<Scalars['String']['input']>;
  evmNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  evmNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** assetPrice edge predicates */
  hasAssetPrice?: InputMaybe<Scalars['Boolean']['input']>;
  hasAssetPriceWith?: InputMaybe<Array<AssetPriceWhereInput>>;
  /** correctnessReport edge predicates */
  hasCorrectnessReport?: InputMaybe<Scalars['Boolean']['input']>;
  hasCorrectnessReportWith?: InputMaybe<Array<CorrectnessReportWhereInput>>;
  /** eventLogs edge predicates */
  hasEventLogs?: InputMaybe<Scalars['Boolean']['input']>;
  hasEventLogsWith?: InputMaybe<Array<EventLogWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  key?: InputMaybe<Scalars['String']['input']>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<SignerWhereInput>;
  or?: InputMaybe<Array<SignerWhereInput>>;
  /** points field predicates */
  points?: InputMaybe<Scalars['Int']['input']>;
  pointsGT?: InputMaybe<Scalars['Int']['input']>;
  pointsGTE?: InputMaybe<Scalars['Int']['input']>;
  pointsIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  pointsLT?: InputMaybe<Scalars['Int']['input']>;
  pointsLTE?: InputMaybe<Scalars['Int']['input']>;
  pointsNEQ?: InputMaybe<Scalars['Int']['input']>;
  pointsNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type DocumentsListQueryVariables = Exact<{
  topic?: InputMaybe<Scalars['String']['input']>;
}>;


export type DocumentsListQuery = { __typename?: 'Query', correctnessReports: { __typename?: 'CorrectnessReportConnection', edges?: Array<{ __typename?: 'CorrectnessReportEdge', node?: { __typename?: 'CorrectnessReport', hash: any, correct: boolean, signerscount: any } | null } | null> | null } };

export type DocumentQueryVariables = Exact<{
  hash?: InputMaybe<Scalars['String']['input']>;
}>;


export type DocumentQuery = { __typename?: 'Query', correctnessReports: { __typename?: 'CorrectnessReportConnection', edges?: Array<{ __typename?: 'CorrectnessReportEdge', node?: { __typename?: 'CorrectnessReport', topic: any, correct: boolean, hash: any, timestamp: any, id: string, signature: any, signerscount: any, signers: Array<{ __typename?: 'Signer', name: string, key: any }> } | null } | null> | null } };


export const DocumentsListDoc = gql`
    query DocumentsList($topic: String) {
  correctnessReports(where: {topic: $topic}) {
    edges {
      node {
        hash
        correct
        signerscount
      }
    }
  }
}
    `;
export const DocumentDoc = gql`
    query Document($hash: String) {
  correctnessReports(where: {hash: $hash}) {
    edges {
      node {
        topic
        correct
        hash
        timestamp
        id
        signature
        signerscount
        signers {
          name
          key
        }
      }
    }
  }
}
    `;
export const DocumentsList = (
            options: Omit<
              WatchQueryOptions<DocumentsListQueryVariables>, 
              "query"
            >
          ): Readable<
            ApolloQueryResult<DocumentsListQuery> & {
              query: ObservableQuery<
                DocumentsListQuery,
                DocumentsListQueryVariables
              >;
            }
          > => {
            const q = client.watchQuery({
              query: DocumentsListDoc,
              ...options,
            });
            var result = readable<
              ApolloQueryResult<DocumentsListQuery> & {
                query: ObservableQuery<
                  DocumentsListQuery,
                  DocumentsListQueryVariables
                >;
              }
            >(
              { data: {} as any, loading: true, error: undefined, networkStatus: 1, query: q },
              (set) => {
                q.subscribe((v: any) => {
                  set({ ...v, query: q });
                });
              }
            );
            return result;
          }
        
              export const AsyncDocumentsList = (
                options: Omit<
                  QueryOptions<DocumentsListQueryVariables>,
                  "query"
                >
              ) => {
                return client.query<DocumentsListQuery>({query: DocumentsListDoc, ...options})
              }
            
export const Document = (
            options: Omit<
              WatchQueryOptions<DocumentQueryVariables>, 
              "query"
            >
          ): Readable<
            ApolloQueryResult<DocumentQuery> & {
              query: ObservableQuery<
                DocumentQuery,
                DocumentQueryVariables
              >;
            }
          > => {
            const q = client.watchQuery({
              query: DocumentDoc,
              ...options,
            });
            var result = readable<
              ApolloQueryResult<DocumentQuery> & {
                query: ObservableQuery<
                  DocumentQuery,
                  DocumentQueryVariables
                >;
              }
            >(
              { data: {} as any, loading: true, error: undefined, networkStatus: 1, query: q },
              (set) => {
                q.subscribe((v: any) => {
                  set({ ...v, query: q });
                });
              }
            );
            return result;
          }
        
              export const AsyncDocument = (
                options: Omit<
                  QueryOptions<DocumentQueryVariables>,
                  "query"
                >
              ) => {
                return client.query<DocumentQuery>({query: DocumentDoc, ...options})
              }
            